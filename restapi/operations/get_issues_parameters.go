// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"

	strfmt "github.com/go-openapi/strfmt"
)

// NewGetIssuesParams creates a new GetIssuesParams object
// with the default values initialized.
func NewGetIssuesParams() GetIssuesParams {
	var (
		directionDefault = string("desc")
		filterDefault    = string("all")
		sortDefault      = string("created")
		stateDefault     = string("open")
	)
	return GetIssuesParams{
		Direction: directionDefault,

		Filter: filterDefault,

		Sort: sortDefault,

		State: stateDefault,
	}
}

// GetIssuesParams contains all the bound params for the get issues operation
// typically these are obtained from a http.Request
//
// swagger:parameters GetIssues
type GetIssuesParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*Is used to set specified media type.
	  In: header
	*/
	Accept *string
	/*You can check the current version of media type in responses.

	  In: header
	*/
	XGitHubMediaType *string
	/*
	  In: header
	*/
	XGitHubRequestID *int64
	/*
	  In: header
	*/
	XRateLimitLimit *int64
	/*
	  In: header
	*/
	XRateLimitRemaining *int64
	/*
	  In: header
	*/
	XRateLimitReset *int64
	/*
	  Required: true
	  In: query
	  Default: "desc"
	*/
	Direction string
	/*Issues assigned to you / created by you / mentioning you / you're
	subscribed to updates for / All issues the authenticated user can see

	  Required: true
	  In: query
	  Default: "all"
	*/
	Filter string
	/*String list of comma separated Label names. Example - bug,ui,@high.
	  Required: true
	  In: query
	*/
	Labels string
	/*Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
	Only issues updated at or after this time are returned.

	  In: query
	*/
	Since *string
	/*
	  Required: true
	  In: query
	  Default: "created"
	*/
	Sort string
	/*
	  Required: true
	  In: query
	  Default: "open"
	*/
	State string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls
func (o *GetIssuesParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error
	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	if err := o.bindAccept(r.Header[http.CanonicalHeaderKey("Accept")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXGitHubMediaType(r.Header[http.CanonicalHeaderKey("X-GitHub-Media-Type")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXGitHubRequestID(r.Header[http.CanonicalHeaderKey("X-GitHub-Request-Id")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXRateLimitLimit(r.Header[http.CanonicalHeaderKey("X-RateLimit-Limit")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXRateLimitRemaining(r.Header[http.CanonicalHeaderKey("X-RateLimit-Remaining")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	if err := o.bindXRateLimitReset(r.Header[http.CanonicalHeaderKey("X-RateLimit-Reset")], true, route.Formats); err != nil {
		res = append(res, err)
	}

	qDirection, qhkDirection, _ := qs.GetOK("direction")
	if err := o.bindDirection(qDirection, qhkDirection, route.Formats); err != nil {
		res = append(res, err)
	}

	qFilter, qhkFilter, _ := qs.GetOK("filter")
	if err := o.bindFilter(qFilter, qhkFilter, route.Formats); err != nil {
		res = append(res, err)
	}

	qLabels, qhkLabels, _ := qs.GetOK("labels")
	if err := o.bindLabels(qLabels, qhkLabels, route.Formats); err != nil {
		res = append(res, err)
	}

	qSince, qhkSince, _ := qs.GetOK("since")
	if err := o.bindSince(qSince, qhkSince, route.Formats); err != nil {
		res = append(res, err)
	}

	qSort, qhkSort, _ := qs.GetOK("sort")
	if err := o.bindSort(qSort, qhkSort, route.Formats); err != nil {
		res = append(res, err)
	}

	qState, qhkState, _ := qs.GetOK("state")
	if err := o.bindState(qState, qhkState, route.Formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (o *GetIssuesParams) bindAccept(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Accept = &raw

	return nil
}

func (o *GetIssuesParams) bindXGitHubMediaType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.XGitHubMediaType = &raw

	return nil
}

func (o *GetIssuesParams) bindXGitHubRequestID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("X-GitHub-Request-Id", "header", "int64", raw)
	}
	o.XGitHubRequestID = &value

	return nil
}

func (o *GetIssuesParams) bindXRateLimitLimit(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("X-RateLimit-Limit", "header", "int64", raw)
	}
	o.XRateLimitLimit = &value

	return nil
}

func (o *GetIssuesParams) bindXRateLimitRemaining(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("X-RateLimit-Remaining", "header", "int64", raw)
	}
	o.XRateLimitRemaining = &value

	return nil
}

func (o *GetIssuesParams) bindXRateLimitReset(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("X-RateLimit-Reset", "header", "int64", raw)
	}
	o.XRateLimitReset = &value

	return nil
}

func (o *GetIssuesParams) bindDirection(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("direction", "query")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if err := validate.RequiredString("direction", "query", raw); err != nil {
		return err
	}

	o.Direction = raw

	if err := o.validateDirection(formats); err != nil {
		return err
	}

	return nil
}

func (o *GetIssuesParams) validateDirection(formats strfmt.Registry) error {

	if err := validate.Enum("direction", "query", o.Direction, []interface{}{"asc", "desc"}); err != nil {
		return err
	}

	return nil
}

func (o *GetIssuesParams) bindFilter(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("filter", "query")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if err := validate.RequiredString("filter", "query", raw); err != nil {
		return err
	}

	o.Filter = raw

	if err := o.validateFilter(formats); err != nil {
		return err
	}

	return nil
}

func (o *GetIssuesParams) validateFilter(formats strfmt.Registry) error {

	if err := validate.Enum("filter", "query", o.Filter, []interface{}{"assigned", "created", "mentioned", "subscribed", "all"}); err != nil {
		return err
	}

	return nil
}

func (o *GetIssuesParams) bindLabels(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("labels", "query")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if err := validate.RequiredString("labels", "query", raw); err != nil {
		return err
	}

	o.Labels = raw

	return nil
}

func (o *GetIssuesParams) bindSince(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if raw == "" { // empty values pass all other validations
		return nil
	}

	o.Since = &raw

	return nil
}

func (o *GetIssuesParams) bindSort(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("sort", "query")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if err := validate.RequiredString("sort", "query", raw); err != nil {
		return err
	}

	o.Sort = raw

	if err := o.validateSort(formats); err != nil {
		return err
	}

	return nil
}

func (o *GetIssuesParams) validateSort(formats strfmt.Registry) error {

	if err := validate.Enum("sort", "query", o.Sort, []interface{}{"created", "updated", "comments"}); err != nil {
		return err
	}

	return nil
}

func (o *GetIssuesParams) bindState(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("state", "query")
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}
	if err := validate.RequiredString("state", "query", raw); err != nil {
		return err
	}

	o.State = raw

	if err := o.validateState(formats); err != nil {
		return err
	}

	return nil
}

func (o *GetIssuesParams) validateState(formats strfmt.Registry) error {

	if err := validate.Enum("state", "query", o.State, []interface{}{"open", "closed"}); err != nil {
		return err
	}

	return nil
}
